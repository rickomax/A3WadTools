using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text.RegularExpressions;
using System.Threading;
using MarcelJoachimKloubert.DWAD;
using MarcelJoachimKloubert.DWAD.WADs.Lumps;
using MarcelJoachimKloubert.DWAD.WADs.Lumps.Linedefs;
using MarcelJoachimKloubert.DWAD.WADs.Lumps.Sectors;
using MarcelJoachimKloubert.DWAD.WADs.Lumps.Sidedefs;
using MarcelJoachimKloubert.DWAD.WADs.Lumps.Things;
using MarcelJoachimKloubert.DWAD.WADs.Lumps.Vertexes;
using UdmfParsing.Udmf;
using WADCommon;
using static WADCommon.Common;

namespace WAD2WMP
{
    internal class Program
    {
        private static readonly Regex Doom1MapRegex = new Regex(@"^E[1-4]M[1-9]$", RegexOptions.Compiled);
        private static readonly Regex Doom2MapRegex = new Regex(@"^MAP[0-9]{2}$", RegexOptions.Compiled);


        private const string WMPHeaderTemplate = "#  This file \"{0}\" was generated by WED v3.29\r\n#  World EDitor for 3D GameStudio by conitec GmbH 1996/1997\r\n#  creation date: 03.04.2024    time: 14:41:30";
        private const string WMPVertexHeaderTemplate = "\r\n\r\n\r\n\r\n#vertex\txpos ypos zpos index\r\n#-------------------------------\r\n";
        private const string WMPRegionHeaderTemplate = "\r\n\r\n\r\n\r\n#region\tname\tfloor_hgt\tceil_hgt\r\n#---------------------------------\r\n";
        private const string WMPWallsHeaderTemplate = "\r\n\r\n\r\n\r\n#wall\tname vertex vertex\tregion region\toffsx offsy\tindex\r\n#------------------------------------------------------------\r\n";
        private const string WMPThingsHeaderTemplate = "\r\n\r\n\r\n\r\n#player_start\r\n#thing\r\n#actor name xpos ypos angle region index\r\n#---------------------------------------\r\n";
        private const string WMPVertexTemplate = "VERTEX\t{0}\t{1}\t{2};#{3}\r\n";
        private const string WMPWallTemplate = "WALL\t{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6};#{7}\r\n";
        private const string WMPRegionTemplate = "REGION\t{0}\t{1}\t{2};#{3}\r\n";
        private const string WMPThingTemplate = "{0}\t{1}\t{2}\t{3}\t{4}\t{5};#{6}\r\n";

        private const string WDLHeaderTemplate = "VIDEO 320x200;\r\nMAPFILE <{0}.WMP>;\r\nBIND <{1}.WDL>;\r\nNEXUS 50;\r\nCLIP_DIST 1000;\r\nLIGHT_ANGLE 1.0;\r\n";
        private const string WDLRegionTemplate = "REGION {0} {{\r\n\tCEIL_TEX {1};\r\n\tFLOOR_TEX {2};\r\n\tAMBIENT {3};\r\n\t{4}\r\n\tFLOOR_HGT {5};\r\n\tCEIL_HGT {6};\r\n}}\r\n";
        private const string WDLRegionBelowTemplate = "REGION {0} {{\r\n\tCEIL_TEX {1};\r\n\tFLOOR_TEX {2};\r\n\tAMBIENT {3};\r\n\tBELOW {4};\r\n\tFLOOR_HGT {5};\r\n\tCEIL_HGT {6};\r\n\t{7}\r\n}}\r\n";
        private const string WDLTextureTemplate = "TEXTURE {0} {{\r\n\tSCALE_XY {2}, {3};\r\n\tBMAPS {1};\r\n}}\r\n";
        private const string WDLBitmapTemplate = "BMAP {0} <{1}>;\r\n";
        private const string WDLWallTemplate = "WALL {0} {{\r\n\tTEXTURE {1};\r\n\tFLAGS PORTCULLIS;\r\n}}\r\n";
        private const string WDLPaletteTemplate = "PALETTE MAINPAL{{\r\n\tPALFILE <{0}>;\r\n\tRANGE 2, 254;\r\n\tFLAGS AUTORANGE;\r\n}}\r\n";

        private const string DefaultPaletteFilename = "PALETTE.PCX";
        private const string BorderRegionName = "BORDERRGN";

        private const string WallTextureSuffix = "WALLTEX";
        private const string RegionTextureSuffix = "REGTEX";

        private const string DummyBitmapFilename = "DUMMY.PCX";
        private const string DummyBitmapName = "DUMMYBMP";
        private const string DummyTextureName = "DUMMYWALLTEX";

        private static readonly char[] Separators = { ',' };

        private struct AcknexThing
        {
            public string Type;
            public string Name;

            public AcknexThing(string type, string name)
            {
                Type = type;
                Name = name;
            }
        }

        static void Main(string[] args)
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
            if (args.Length < 4)
            {
                Console.WriteLine("WAD2WMP - Usage: <Input WAD Path> <Output WMP Path> <Output WDL Path> <First Map Marker> <Add WDL Header: Y/N> <Optional: Force Dummy Textures Y/N>");
                Console.ReadKey();
                return;
            }
            var wadPath = args[0];
            if (!IsValidPath(wadPath) || !File.Exists(wadPath))
            {
                Console.WriteLine($"\"{wadPath}\" not found");
                Console.ReadKey();
                return;
            }
            var wmpPath = args[1];
            if (!IsValidPath(wmpPath))
            {
                Console.WriteLine($"\"{wmpPath}\" is not a valid path");
                Console.ReadKey();
                return;
            }
            var wdlPath = args[2];
            if (!IsValidPath(wdlPath))
            {
                Console.WriteLine($"\"{wdlPath}\" is not a valid path");
                Console.ReadKey();
                return;
            }
            var mapMarker = args[3];
            if (string.IsNullOrWhiteSpace(mapMarker))
            {
                Console.WriteLine($"Map Marker not specified");
                Console.ReadKey();
                return;
            }
            var addWdlHeader = args[4] == "Y" || args[4] == "y";
            var forceDummyTextures = args.Length >= 6 && args[5] == "Y" || args[5] == "y";
            var wmpFilename = Path.GetFileNameWithoutExtension(wmpPath);
            var wdlFilename = Path.GetFileNameWithoutExtension(wdlPath);
            var wdlDirectory = Path.GetDirectoryName(wdlPath);
            if (string.IsNullOrEmpty(wdlDirectory))
            {
                wdlDirectory = AppDomain.CurrentDomain.BaseDirectory;
            }
            using (var wdlStream = File.Create(wdlPath))
            {
                using (var wdlStreamWriter = new StreamWriter(wdlStream))
                {
                    using (var wmpStream = File.Create(wmpPath))
                    {
                        using (var wmpStreamWriter = new StreamWriter(wmpStream))
                        {
                            using (var wadStream = File.OpenRead(wadPath))
                            {
                                foreach (var wadFile in WADFileFactory.FromStream(wadStream))
                                {
                                    if (addWdlHeader)
                                    {
                                        wdlStreamWriter.Write(WDLHeaderTemplate, wmpFilename, wdlFilename);
                                    }

                                    var lumps = GetLumpsBetweenMapMarkers(wadFile.EnumerateLumps(), mapMarker);

                                    List<ISector> allSectors;
                                    List<IVertex> allVertices;
                                    List<IThing> allThings;
                                    List<ILinedef> allLinedefs;
                                    List<ISidedef> allSidedefs;

                                    bool udmfMap;

                                    var textMap = lumps.FirstOrDefault(x => x.Name == "TEXTMAP");
                                    if (textMap != null)
                                    {
                                        udmfMap = true;

                                        allSectors = new List<ISector>();
                                        allVertices = new List<IVertex>();
                                        allThings = new List<IThing>();
                                        allLinedefs = new List<ILinedef>();
                                        allSidedefs = new List<ISidedef>();

                                        var mapData = MapData.LoadFromUsingTotallyCustom(textMap.GetStream());
                                        if (mapData != null)
                                        {
                                            foreach (var vertex in mapData.Vertices)
                                            {
                                                var newVertex = new UDMFVertex();
                                                newVertex.X = (short)vertex.X;
                                                newVertex.Y = (short)vertex.Y;
                                                allVertices.Add(newVertex);
                                            }

                                            foreach (var sector in mapData.Sectors)
                                            {
                                                var newSector = new UDMFSector();
                                                newSector.CeilingHeight = (short)sector.HeightCeiling;
                                                newSector.CeilingTexture = sector.TextureCeiling;
                                                newSector.FloorHeight = (short)sector.HeightFloor;
                                                newSector.FloorTexture = sector.TextureFloor;
                                                newSector.LightLevel = (short)sector.LightLevel;
                                                newSector.SpecialType = (short)sector.Special;
                                                newSector.TagNumber = (short)sector.Id;
                                                allSectors.Add(newSector);
                                            }

                                            foreach (var sidedef in mapData.SideDefs)
                                            {
                                                var newSidedef = new UDMFSidedef();
                                                newSidedef.SectorIndex = (short)sidedef.Sector;
                                                newSidedef.Sector = allSectors[sidedef.Sector];
                                                newSidedef.MiddleTexture = sidedef.TextureMiddle;
                                                newSidedef.UpperTexture = sidedef.TextureTop;
                                                newSidedef.LowerTexture = sidedef.TextureBottom;
                                                newSidedef.XOffset = (short)sidedef.OffsetX;
                                                newSidedef.YOffset = (short)sidedef.OffsetY;
                                                allSidedefs.Add(newSidedef);
                                            }

                                            foreach (var linedef in mapData.LineDefs)
                                            {
                                                var newLinedef = new UDMFLinedef();
                                                newLinedef.StartVertexIndex = (short)linedef.V1;
                                                newLinedef.EndVertexIndex = (short)linedef.V2;
                                                newLinedef.Start = allVertices[linedef.V1];
                                                newLinedef.End = allVertices[linedef.V2];
                                                newLinedef.RightSideIndex = (short)linedef.SideFront;
                                                newLinedef.RightSide = linedef.SideFront > -1 ? allSidedefs[linedef.SideFront] : null;
                                                newLinedef.LeftSideIndex = (short)linedef.SideBack;
                                                newLinedef.LeftSide = linedef.SideBack > 1 ? allSidedefs[linedef.SideBack] : null;
                                                newLinedef.SpecialType = (short)linedef.Special;
                                                newLinedef.Arg0 = linedef.Arg0;
                                                newLinedef.Arg1 = linedef.Arg1;
                                                newLinedef.Arg2 = linedef.Arg2;
                                                newLinedef.Arg3 = linedef.Arg3;
                                                newLinedef.Arg4 = linedef.Arg4;
                                                allLinedefs.Add(newLinedef);
                                            }

                                            foreach (var thing in mapData.Things)
                                            {
                                                var newThing = new UDMFThing();
                                                newThing.X = (short)thing.X;
                                                newThing.Y = (short)thing.Y;
                                                newThing.Angle = (short)thing.Angle;
                                                newThing.Index = thing.Id;
                                                newThing.Type = (short)thing.Type;
                                                allThings.Add(newThing);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        udmfMap = false;

                                        allSectors = lumps
                                            .OfType<ISectorsLump>()
                                            .SelectMany(x => x.EnumerateSectors()).ToList();
                                        allVertices = lumps
                                            .OfType<IVertexesLump>()
                                            .SelectMany(x => x.EnumerateVertexes()).ToList();
                                        allThings = lumps
                                            .OfType<IThingsLump>()
                                            .SelectMany(x => x.EnumerateThings()).ToList();
                                        allLinedefs = lumps
                                            .OfType<ILinedefsLump>()
                                            .SelectMany(x => x.EnumerateLinedefs()).ToList();
                                    }

                                    wdlStreamWriter.Write(WDLBitmapTemplate, DummyBitmapName, DummyBitmapFilename);
                                    wdlStreamWriter.Write(WDLTextureTemplate, DummyTextureName, DummyBitmapName, AckScale, AckScale);

                                    var processedTextures = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                                    Color[] palette = null;
                                    var playPal = lumps.FirstOrDefault(x => x.Name == "PLAYPAL");
                                    if (playPal != null)
                                    {
                                        var palData = ReadFully(playPal.GetStream());
                                        palette = new Color[256];
                                        for (int i = 0, offset = 0; i < 256; i++, offset += 3)
                                        {
                                            palette[i] = new Color(palData[offset], palData[offset + 1], palData[offset + 2]);
                                        }
                                        var pixelData = new byte[256];
                                        for (var i = 0; i < 256; i++)
                                        {
                                            pixelData[i] = (byte)i;
                                        }
                                        ExtractTexture(playPal, delegate (BinaryWriter textureWriter)
                                        {
                                            PCXWriter.WritePCX(pixelData, 256, 1, palette, textureWriter);
                                        }, wdlStreamWriter, processedTextures, wdlDirectory, false);
                                        wdlStreamWriter.Write(WDLPaletteTemplate, "PLAYPAL.PCX");
                                    }
                                    else
                                    {
                                        wdlStreamWriter.Write(WDLPaletteTemplate, DefaultPaletteFilename);
                                    }

                                    var insideTextures = false;
                                    var insideFlats = false;
                                    var insidePatches = false;
                                    var availableTextures = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                                    var dummyTextures = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                                    var ackTable = new Dictionary<short, AcknexThing>();

                                    foreach (var lump in lumps)
                                    {
                                        if (!forceDummyTextures)
                                        {
                                            switch (lump.Name)
                                            {
                                                case "ACKTABLE": //todo
                                                    {
                                                        var streamReader = new StreamReader(lump.GetStream());
                                                        var acktableContent = streamReader.ReadToEnd();
                                                        var lines = acktableContent.Split('\n', '\r');
                                                        foreach (var line in lines)
                                                        {
                                                            if (string.IsNullOrWhiteSpace(line))
                                                            {
                                                                continue;
                                                            }
                                                            var data = line.Split(Separators, StringSplitOptions.RemoveEmptyEntries);
                                                            ackTable.Add(short.Parse(data[0]), new AcknexThing(data[1], data[2]));
                                                        }
                                                        continue;
                                                    }
                                                case "TX_START":
                                                    insideTextures = true;
                                                    continue;
                                                case "TX_END":
                                                    insideTextures = false;
                                                    continue;
                                                case "P1_START":
                                                case "P2_START":
                                                    insidePatches = true;
                                                    continue;
                                                case "P1_END":
                                                case "P2_END":
                                                    insidePatches = false;
                                                    continue;
                                                case "F1_START":
                                                case "F2_START":
                                                    insideFlats = true;
                                                    continue;
                                                case "F1_END":
                                                case "F2_END":
                                                    insideFlats = false;
                                                    continue;
                                            }
                                            var width = 0;
                                            var height = 0;
                                            byte[] pixelData = null;
                                            var textureData = ReadFully(lump.GetStream());
                                            if (availableTextures.Contains(lump.Name))
                                            {
                                                continue;
                                            }
                                            if (insideFlats)
                                            {
                                                if (palette == null)
                                                {
                                                    Console.WriteLine($"Skipping image {lump.Name} because a palette has not been found");
                                                    continue;
                                                }
                                                if (textureData.Length != 4096)
                                                {
                                                    Console.WriteLine($"Skipping image {lump.Name} because it isn't a 64x64 flat");
                                                    continue;
                                                }
                                                width = 64;
                                                height = 64;
                                                pixelData = textureData;
                                            }
                                            else if (insidePatches || insideTextures)
                                            {
                                                if (palette == null)
                                                {
                                                    Console.WriteLine($"Skipping image {lump.Name} because a palette has not been found");
                                                    continue;
                                                }
                                                if (textureData.Length >= 2 && textureData[0] == 10 && textureData[1] == 5) //PCX
                                                {
                                                    availableTextures.Add(lump.Name);
                                                    ExtractTexture(lump, delegate (BinaryWriter textureWriter)
                                                    {
                                                        textureWriter.Write(textureData);
                                                    }, wdlStreamWriter, processedTextures, wdlDirectory);
                                                }
                                                else
                                                {
                                                    width = GetInt16Le(textureData, 0);
                                                    height = GetInt16Le(textureData, 2);
                                                    pixelData = new byte[width * height];
                                                    for (var i = 0; i < pixelData.Length; i++)
                                                    {
                                                        pixelData[i] = 255;
                                                    }

                                                    for (var column = 0; column < width; column++)
                                                    {
                                                        var pointer = GetInt32Le(textureData, (column * 4) + 8);
                                                        do
                                                        {
                                                            int postHeight;
                                                            var row = textureData[pointer];
                                                            if (row != 255 && (postHeight = textureData[++pointer]) != 255)
                                                            {
                                                                pointer++;
                                                                for (var i = 0; i < postHeight; i++)
                                                                {
                                                                    if (row + i < height && pointer < textureData.Length - 1)
                                                                    {
                                                                        pixelData[((row + i) * width) + column] = textureData[++pointer];
                                                                    }
                                                                }

                                                                pointer++;
                                                            }
                                                            else
                                                            {
                                                                break;
                                                            }
                                                        } while (pointer < textureData.Length - 1 && textureData[++pointer] != 255);
                                                    }
                                                }
                                            }
                                            if (pixelData != null)
                                            {
                                                availableTextures.Add(lump.Name);
                                                ExtractTexture(lump, delegate (BinaryWriter textureWriter)
                                                {
                                                    PCXWriter.WritePCX(pixelData, width, height, palette, textureWriter);
                                                }, wdlStreamWriter, processedTextures, wdlDirectory);
                                            }
                                        }
                                    }

                                    wmpStreamWriter.Write(WMPHeaderTemplate);

                                    var vertexHeights = new short[allVertices.Count];
                                    var sectorSlope = new int[allSectors.Count];
                                    var sectorDir = new int[allSectors.Count];

                                    foreach (var linedef in allLinedefs)
                                    {
                                        if (IsLowerFrontSlope(linedef.SpecialType, udmfMap, linedef.Arg0))
                                        {
                                            var leftSideSector = linedef.LeftSide.Sector;
                                            vertexHeights[linedef.StartVertexIndex] = leftSideSector.FloorHeight;
                                            vertexHeights[linedef.EndVertexIndex] = leftSideSector.FloorHeight;
                                            var p1 = ToVector2(linedef.Start);
                                            var p2 = ToVector2(linedef.End);
                                            var perpendicular = Perpendicular(p1 - p2);
                                            var frontSectorLinedefs = allLinedefs.Where(x => x.RightSide.SectorIndex == linedef.RightSide.SectorIndex).ToList();
                                            var fartestP = 0f;
                                            foreach (var frontLinedef in frontSectorLinedefs)
                                            {
                                                var fp1 = ToVector2(frontLinedef.Start) - p1;
                                                var fp2 = ToVector2(frontLinedef.End) - p1;

                                                var f1 = Vector2.Dot(perpendicular, fp1) / perpendicular.Length();
                                                var f2 = Vector2.Dot(perpendicular, fp2) / perpendicular.Length();

                                                fartestP = Math.Max(fartestP, f1);
                                                fartestP = Math.Max(fartestP, f2);
                                            }
                                            foreach (var frontLinedef in frontSectorLinedefs)
                                            {
                                                var fp1 = ToVector2(frontLinedef.Start) - p1;
                                                var fp2 = ToVector2(frontLinedef.End) - p1;

                                                var f1 = Vector2.Dot(perpendicular, fp1) / perpendicular.Length() / fartestP;
                                                var f2 = Vector2.Dot(perpendicular, fp2) / perpendicular.Length() / fartestP;

                                                var rightSideSector = frontLinedef.RightSide.Sector;

                                                vertexHeights[frontLinedef.StartVertexIndex] = (short)(Lerp(leftSideSector.FloorHeight, rightSideSector.FloorHeight, f1));
                                                vertexHeights[frontLinedef.EndVertexIndex] = (short)(Lerp(leftSideSector.FloorHeight, rightSideSector.FloorHeight, f2));
                                            }
                                            sectorSlope[linedef.RightSide.SectorIndex] = linedef.SpecialType;
                                            sectorDir[linedef.RightSide.SectorIndex] = linedef.Arg0;
                                        }
                                    }

                                    var vertexIndex = 0;
                                    wmpStreamWriter.Write(WMPVertexHeaderTemplate);
                                    for (var i = 0; i < allVertices.Count; i++)
                                    {
                                        var vertex = allVertices[i];
                                        wmpStreamWriter.Write(WMPVertexTemplate, vertex.X * Scale, vertex.Y * Scale, vertexHeights[i] * Scale, vertexIndex++);
                                    }

                                    var sectorIndex = 0;
                                    wmpStreamWriter.Write(WMPRegionHeaderTemplate);
                                    wmpStreamWriter.Write(WMPRegionTemplate, BorderRegionName, 0f, 0f, sectorIndex++);
                                    wdlStreamWriter.Write(WDLRegionTemplate, BorderRegionName, DummyTextureName, DummyTextureName, 1f, "", 0f, 0f);

                                    foreach (var linedef in allLinedefs)
                                    {
                                        if (Is3DFloor(linedef, udmfMap))
                                        {
                                            var baseSector = allSectors.FirstOrDefault(x => x.TagNumber == linedef.SectorTag);
                                            if (baseSector != null)
                                            {
                                                var tridimensionalSector = linedef.RightSide.Sector;
                                                var baseSectorIndex = allSectors.IndexOf(baseSector) + 1;
                                                var regionName = $"TREGION{baseSectorIndex}BELOW";
                                                //floor, ceil
                                                wdlStreamWriter.Write(WDLRegionTemplate,
                                                    regionName,
                                                    forceDummyTextures ? DummyTextureName : ProcessTexture(wdlStreamWriter, availableTextures, dummyTextures, tridimensionalSector.CeilingTexture, true),
                                                    forceDummyTextures ? DummyTextureName : ProcessTexture(wdlStreamWriter, availableTextures, dummyTextures, baseSector.FloorTexture, true),
                                                    tridimensionalSector.LightLevel == 0 ? 0f : tridimensionalSector.LightLevel / 255f,
                                                    "",
                                                    baseSector.FloorHeight * Scale,
                                                    tridimensionalSector.FloorHeight * Scale
                                                );
                                            }
                                        }
                                    }

                                    for (var i = 0; i < allSectors.Count; i++)
                                    {
                                        var sector = allSectors[i];
                                        var regionName = $"TREGION{sectorIndex}";
                                        var tridimensionalLinedef = GetTridimensonalLinedefs(allLinedefs, sector, udmfMap);
                                        if (tridimensionalLinedef == null)
                                        {
                                            wmpStreamWriter.Write(WMPRegionTemplate, regionName, sectorSlope[i] == 0 ? sector.FloorHeight * Scale : 0, sector.CeilingHeight * Scale, sectorIndex);
                                            wdlStreamWriter.Write(WDLRegionTemplate,
                                                regionName,
                                                forceDummyTextures ? DummyTextureName : ProcessTexture(wdlStreamWriter, availableTextures, dummyTextures, sector.CeilingTexture, true),
                                                forceDummyTextures ? DummyTextureName : ProcessTexture(wdlStreamWriter, availableTextures, dummyTextures, sector.FloorTexture, true),
                                                sector.LightLevel == 0 ? 0f : sector.LightLevel / 255f,
                                                WriteSlope(sectorSlope[i], udmfMap, sectorDir[i]),
                                                sectorSlope[i] == 0 ? sector.FloorHeight * Scale : 0,
                                                sector.CeilingHeight * Scale
                                            );
                                        }
                                        else
                                        {
                                            //floor, ceil
                                            var tridimensionalSector = tridimensionalLinedef.RightSide.Sector;
                                            wmpStreamWriter.Write(WMPRegionTemplate, regionName, tridimensionalSector.CeilingHeight * Scale, sector.CeilingHeight * Scale, sectorIndex);
                                            wdlStreamWriter.Write(WDLRegionBelowTemplate,
                                                regionName,
                                                forceDummyTextures ? DummyTextureName : ProcessTexture(wdlStreamWriter, availableTextures, dummyTextures, sector.CeilingTexture, true),
                                                forceDummyTextures ? DummyTextureName : ProcessTexture(wdlStreamWriter, availableTextures, dummyTextures, tridimensionalSector.FloorTexture, true),
                                                sector.LightLevel == 0 ? 0f : sector.LightLevel / 255f,
                                                $"{regionName}BELOW",
                                                tridimensionalSector.CeilingHeight * Scale,
                                                sector.CeilingHeight * Scale,
                                                WriteSlope(sectorSlope[i], udmfMap, sectorDir[i])
                                            );
                                        }

                                        sectorIndex++;
                                    }

                                    var wallIndex = 0;
                                    wmpStreamWriter.Write(WMPWallsHeaderTemplate);
                                    foreach (var linedef in allLinedefs)
                                    {
                                        var wallName = $"TWALL{wallIndex}";
                                        var rightSide = linedef.RightSide;
                                        var leftSide = linedef.LeftSide;
                                        var vIndex1 = linedef.StartVertexIndex;
                                        var vIndex2 = linedef.EndVertexIndex;
                                        var rightSideSectorIndex = rightSide.SectorIndex + 1;
                                        var leftSideSectorIndex = leftSide == null ? 0 : leftSide.SectorIndex + 1;
                                        wmpStreamWriter.Write(WMPWallTemplate, wallName, vIndex1, vIndex2, leftSideSectorIndex, rightSideSectorIndex, rightSide.XOffset * Scale, rightSide.YOffset != 0 ? (rightSide.YOffset - 5f) * Scale : 0f, wallIndex++);
                                        wdlStreamWriter.Write(WDLWallTemplate, wallName, forceDummyTextures ? DummyTextureName : ProcessTexture(wdlStreamWriter, availableTextures, dummyTextures, SelectTexture(leftSide, rightSide, linedef)));
                                    }

                                    var thingIndex = 0;
                                    wmpStreamWriter.Write(WMPThingsHeaderTemplate);
                                    foreach (var thing in allThings)
                                    {
                                        if (thing.Type == 1)
                                        {
                                            wmpStreamWriter.Write(WMPThingTemplate, "player_start", "", thing.X * Scale, thing.Y * Scale, thing.Angle, FindRegion(thing, allSectors, allLinedefs), thingIndex++);
                                        }
                                        else if (ackTable.TryGetValue(thing.Type, out var acknexThing))
                                        {
                                            wmpStreamWriter.Write(WMPThingTemplate, acknexThing.Type, acknexThing.Name, thing.X * Scale, thing.Y * Scale, thing.Angle, FindRegion(thing, allSectors, allLinedefs), thingIndex++);
                                        }
                                    }
                                    Console.WriteLine("Finished exporting. Press any key to exit");
                                    Console.ReadKey();
                                }
                            }
                        }
                    }
                }
            }
        }

        private static List<ILump> GetLumpsBetweenMapMarkers(IEnumerable<ILump> lumps, string mapMarker)
        {
            if (lumps == null)
            {
                throw new ArgumentNullException(nameof(lumps));
            }
            if (string.IsNullOrEmpty(mapMarker))
            {
                throw new ArgumentException("Map marker cannot be null or empty.", nameof(mapMarker));
            }
            var result = new List<ILump>();
            var foundStartMarker = false;
            foreach (var lump in lumps)
            {
                if (!foundStartMarker && lump.Name == mapMarker)
                {
                    foundStartMarker = true;
                }
                if (foundStartMarker)
                {
                    result.Add(lump);
                    if (result.Count > 1 && IsMapMarker(lump))
                    {
                        result.RemoveAt(result.Count - 1);
                        break;
                    }
                }
            }
            return result;
        }

        private static bool IsMapMarker(ILump lump)
        {
            if (lump == null || string.IsNullOrEmpty(lump.Name))
            {
                return false;
            }

            return Doom1MapRegex.IsMatch(lump.Name) || Doom2MapRegex.IsMatch(lump.Name);
        }

        private static ILinedef GetTridimensonalLinedefs(List<ILinedef> allLinedefs, ISector sector, bool udmfMap)
        {
            return !udmfMap ?
                allLinedefs.FirstOrDefault(x => x.SectorTag == sector.TagNumber && x.SpecialType >= 281 && x.SpecialType <= 300) :
                allLinedefs.FirstOrDefault(x => x.SectorTag == sector.TagNumber && x.SpecialType == 160 && x.Arg1 == 1);
        }

        private static bool Is3DFloor(ILinedef linedef, bool udmfMap)
        {
            if (!udmfMap)
            {
                return linedef.SpecialType >= 281 && linedef.SpecialType <= 300;
            }

            var result = linedef.SpecialType == 160 && linedef.Arg1 == 1;
            if (result)
            {
                linedef.SectorTag = (short)linedef.Arg0; //todo: hack
            }
            return result;
        }

        public static float Lerp(float a, float b, float t)
        {
            t = Math.Max(0.0f, Math.Min(1.0f, t));
            return a + (b - a) * t;
        }

        private static Vector2 Perpendicular(Vector2 vector)
        {
            return new Vector2(-vector.Y, vector.X);
        }

        private static Vector2 ToVector2(IVertex vertex)
        {
            return new Vector2(vertex.X, vertex.Y);
        }


        private static bool IsLowerFrontSlope(int special, bool udmfMap, int arg0)
        {
            if (!udmfMap)
            {
                return special == 340;  //doom-legacy
            }

            return special == 181 && arg0 == 1; //plane-align
        }

        private static string WriteSlope(int value, bool udmfMap, int arg0)
        {
            return IsLowerFrontSlope(value, udmfMap, arg0) ? "FLAGS FLOOR_ASCEND;" : "";
        }

        private static string ProcessTexture(StreamWriter wdlStreamWriter, HashSet<string> availableTextures, HashSet<string> dummyTextures, string texture, bool isRegion = false)
        {
            if (texture == "-")
            {
                return DummyTextureName;
            }
            if (!availableTextures.Contains(texture) && !dummyTextures.Contains(texture))
            {
                dummyTextures.Add(texture);
                Console.WriteLine($"Could not find texture {texture}");
                WriteTextureAndBitmap(texture, wdlStreamWriter, DummyBitmapFilename);
            }

            return $"{texture}{(isRegion ? RegionTextureSuffix : WallTextureSuffix)}";
        }

        private static void ExtractTexture(ILump lump, Action<BinaryWriter> writingDelegate, StreamWriter wdlStreamWriter, HashSet<string> processedTextures, string wdlDirectory, bool writeWDL = true)
        {
            var textureFilename = $"{lump.Name}.pcx";
            var texturePath = $"{wdlDirectory}\\{textureFilename}";
            if (IsValidPath(texturePath))
            {
                using (var textureStream = new BinaryWriter(File.Create(texturePath)))
                {
                    writingDelegate(textureStream);
                }
            }
            if (!processedTextures.Add(lump.Name))
            {
                Console.WriteLine($"Duplicated texture definition:{lump.Name}");
                return;
            }
            if (writeWDL)
            {
                WriteTextureAndBitmap(lump.Name, wdlStreamWriter, textureFilename);
            }
        }

        private static void WriteTextureAndBitmap(string name, StreamWriter wdlStreamWriter, string textureFilename)
        {
            var bitmapName = $"{name}BMP";
            var wallTextureName = $"{name}{WallTextureSuffix}";
            var regionTextureName = $"{name}{RegionTextureSuffix}";
            wdlStreamWriter.Write(WDLBitmapTemplate, bitmapName, textureFilename);
            wdlStreamWriter.Write(WDLTextureTemplate, wallTextureName, bitmapName, -AckScale, AckScale);
            wdlStreamWriter.Write(WDLTextureTemplate, regionTextureName, bitmapName, -AckScale, -AckScale);
        }

        private static string SelectTexture(ISidedef leftSide, ISidedef rightSide, ILinedef linedef)
        {
            if (linedef.LeftSide?.Sector == null)
            {
                if (rightSide.MiddleTexture != "-")
                {
                    return rightSide.MiddleTexture;
                }
            }
            else if (linedef.RightSide?.Sector == null)
            {
                if (leftSide.MiddleTexture != "-")
                {
                    return leftSide.MiddleTexture;
                }
            }
            else
            {
                var topGap = Math.Abs(linedef.RightSide.Sector.CeilingHeight - linedef.LeftSide.Sector.CeilingHeight);
                var bottomGap = Math.Abs(linedef.RightSide.Sector.FloorHeight - linedef.LeftSide.Sector.FloorHeight);
                if (topGap == 0 && bottomGap == 0)
                {
                    if (linedef.RightSide.MiddleTexture == "-")
                    {
                        if (linedef.LeftSide.MiddleTexture != "-")
                        {
                            return linedef.LeftSide.MiddleTexture;
                        }
                    }
                    else
                    {
                        return linedef.RightSide.MiddleTexture;
                    }
                }
                else if (topGap > bottomGap)
                {
                    if (linedef.RightSide.UpperTexture == "-")
                    {
                        if (linedef.LeftSide.UpperTexture != "-")
                        {
                            return linedef.LeftSide.UpperTexture;
                        }
                    }
                    else
                    {
                        return linedef.RightSide.UpperTexture;
                    }
                }
                if (linedef.RightSide.LowerTexture == "-")
                {
                    if (linedef.LeftSide.LowerTexture != "-")
                    {
                        return linedef.LeftSide.LowerTexture;
                    }
                }
                else
                {
                    return linedef.RightSide.LowerTexture;
                }
            }
            return $"{DummyTextureName}WALLTEX";
        }

        //todo: fixme
        private static int FindRegion(IThing thing, List<ISector> allSectors, IList<ILinedef> allLinedefs)
        {
            return 0;
            var deepestSector = -1;
            var deepestNestingLevel = -1;

            for (var sectorIndex = 0; sectorIndex < allSectors.Count; sectorIndex++)
            {
                var sector = allSectors[sectorIndex];
                var sectorLines = allLinedefs.Where(lineDef => lineDef.RightSide?.SectorIndex == sectorIndex);

                var polygon = sectorLines
                    .SelectMany(line => new[] { new Point(line.Start.X, line.Start.Y), new Point(line.End.X, line.End.Y) })
                    .Distinct()
                    .ToList();

                if (IsPointInPolygon(new Point(thing.X, thing.Y), polygon))
                {
                    var nestingLevel = CalculateNestingLevel(sector, allSectors, allLinedefs);

                    if (nestingLevel > deepestNestingLevel)
                    {
                        deepestNestingLevel = nestingLevel;
                        deepestSector = sectorIndex;
                    }
                }
            }

            return deepestSector;
        }

        private static bool IsPointInPolygon(Point point, List<Point> polygon)
        {
            var result = false;
            var j = polygon.Count() - 1;
            for (var i = 0; i < polygon.Count(); i++)
            {
                if (polygon[i].Y < point.Y && polygon[j].Y >= point.Y || polygon[j].Y < point.Y && polygon[i].Y >= point.Y)
                {
                    if (polygon[i].X + (point.Y - polygon[i].Y) / (polygon[j].Y - polygon[i].Y) * (polygon[j].X - polygon[i].X) < point.X)
                    {
                        result = !result;
                    }
                }
                j = i;
            }
            return result;
        }

        private static int CalculateNestingLevel(ISector sector, List<ISector> allSectors, IList<ILinedef> allLinedefs)
        {
            var nestingLevel = 0;

            foreach (var otherSector in allSectors)
            {
                if (otherSector == sector)
                {
                    continue;
                }

                var otherSectorLines = allLinedefs.Where(lineDef => lineDef.RightSide?.Sector == otherSector).ToList();

                var otherPolygon = otherSectorLines
                    .SelectMany(line => new[] { new Point(line.Start.X, line.Start.Y), new Point(line.End.X, line.End.Y) })
                    .Distinct()
                    .ToList();

                var centroid = CalculateCentroid(otherPolygon);
                if (IsPointInPolygon(centroid, otherPolygon))
                {
                    nestingLevel++;
                }
            }

            return nestingLevel;
        }

        private static Point CalculateCentroid(List<Point> polygon)
        {
            float centroidX = 0f, centroidY = 0f;
            var n = polygon.Count;

            foreach (var point in polygon)
            {
                centroidX += point.X;
                centroidY += point.Y;
            }

            centroidX /= n;
            centroidY /= n;

            return new Point(centroidX, centroidY);
        }

    }
}
